package me.alek.serversecurity.malware.scanning;

import me.alek.serversecurity.malware.CacheContainer;
import me.alek.serversecurity.malware.model.result.CheckResult;
import me.alek.serversecurity.utils.Appender;
import me.alek.serversecurity.utils.ZipUtils;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

public abstract class JarBytecodeScanner<T, V> {

    private final List<File> files = new ArrayList<>();
    private final ConcurrentLinkedQueue<File> queriedFiles = new ConcurrentLinkedQueue<>();
    private final Map<String, List<T>> resultData = new HashMap<>();
    private final List<T> flatResultData = new ArrayList<>();

    private boolean error;
    private boolean completed;
    private boolean scanning;
    private final int size;
    private final AtomicInteger done = new AtomicInteger();
    private final ScannerDelegate<T, V> scannerDelegate;

    private CountDownLatch scanningWaitingLatch = null;

    public abstract Comparator<T> getComparator();

    public JarBytecodeScanner(List<File> files, ScannerDelegateFactory<T, V> scannerDelegateFactory) {
        this.queriedFiles.addAll(files);
        this.files.addAll(files);

        this.scannerDelegate = scannerDelegateFactory.create();
        this.size = files.size();
    }

    public JarBytecodeScanner(File file, ScannerDelegateFactory<T, V> scannerDelegateFactory) {
        this(Collections.singletonList(file), scannerDelegateFactory);
    }

    public ScannerDelegate<T, V> getScannerDelegate() {
        return scannerDelegate;
    }

    public void startScan() { startScan(null); }

    public synchronized void startScan(Appender whenDone) {
        if (scanning || completed) return;

        scanning = true;
        scanningWaitingLatch = new CountDownLatch(1);

        final CountDownLatch mainThreadWaitingLatch = new CountDownLatch(size);

        scannerDelegate.handlePreScan();
        try {
            // check if there is any more files left to be scanned
            while (!queriedFiles.isEmpty()) {

                // poll an entry from the queue and count down the latch
                final File file = queriedFiles.poll();

                // run the scan async
                CompletableFuture.runAsync(() -> {
                    final FileSystem fs = ZipUtils.fileSystemForZip(file.toPath());
                    if (fs == null) return;

                    final CacheContainer cache = new CacheContainer();

                    final Iterator<Path> rootFolderIterator = fs.getRootDirectories().iterator();
                    if (!rootFolderIterator.hasNext()) return;
                    final Path rootFolder = rootFolderIterator.next();

                    ScannerEventually<T, V> registry = scannerDelegate.preHandleAndGetRegistry(file, rootFolder);

                    Stream<Path> validClasses = ZipUtils.walkThroughFiles(rootFolder);
                    Iterator<Path> validClassIterator = validClasses.iterator();

                    while (validClassIterator.hasNext()) {
                        Path classPath = validClassIterator.next();
                        boolean validClassPath = ZipUtils.validClassPath(classPath);

                        ClassNode classNode = cache.fetchClass(file.toPath(), classPath);

                        scannerDelegate.handle(registry, classPath, classNode, file, validClassPath);
                    }
                    registry.doAdding(resultData.computeIfAbsent(file.getName(), (d) -> new ArrayList<>()));
                    try {
                        fs.close();
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }

                }).exceptionally((ex) -> {
                    ex.printStackTrace();
                    return null;
                }).thenRun(() -> {
                    // register the result
                    done.incrementAndGet();

                    // release the barrier
                    mainThreadWaitingLatch.countDown();
                });
            }
            mainThreadWaitingLatch.await();
            scannerDelegate.handlePostScan();

            scanning = false;
            completed = true;

            for (List<T> list : resultData.values()) {
                flatResultData.addAll(list);
            }

            // let us sort the results to be outputted
            synchronized (flatResultData) {
                if (getComparator() != null) flatResultData.sort(getComparator());
            }

            // run any appender waiting
            if (whenDone != null) whenDone.onResponse();
        } catch (Exception ex) {
            error = true;
            ex.printStackTrace();
        }
        finally {
            scanningWaitingLatch.countDown();
        }
    }

    public void await() {
        if (!scanning) return;

        try {
            scanningWaitingLatch.await();

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public double getResultLevel(List<CheckResult> results) {
        double totalLevel = 0;
        for (CheckResult result : results) {
            if (result == null) continue;
            totalLevel += result.getRisk().getDetectionLevel();
        }
        return totalLevel;
    }

    public ConcurrentLinkedQueue<File> getRemainingFiles() {
        return queriedFiles;
    }

    public List<File> getFiles() {
        return files;
    }

    public Map<String, List<T>> getResultData() {
        return resultData;
    }

    public List<T> getFlatResultData() {
        return flatResultData;
    }

    public boolean isScanning() {
        return scanning;
    }

    public boolean isError() {
        return this.error;
    }

    public int getSize() {
        return size;
    }

    public int getDoneFiles() {
        return done.get();
    }
}
