package me.alek.serversecurity.malware.scanning;

import me.alek.serversecurity.lang.Lang;
import me.alek.serversecurity.malware.CacheContainer;
import me.alek.serversecurity.malware.checks.BaseCheck;
import me.alek.serversecurity.malware.constants.checks.Checks;
import me.alek.serversecurity.logging.LogHolder;
import me.alek.serversecurity.malware.enums.Risk;
import me.alek.serversecurity.model.PluginProperties;
import me.alek.serversecurity.malware.model.ResultData;
import me.alek.serversecurity.malware.model.result.CheckResult;
import me.alek.serversecurity.malware.model.result.MalwareCheckResult;
import me.alek.serversecurity.utils.Appender;
import me.alek.serversecurity.utils.ZipUtils;
import org.apache.logging.log4j.Level;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class VulnerabilityScanner {

    public static VulnerabilityScanner latestScanner;

    private final List<File> files = new ArrayList<>();
    private final ConcurrentLinkedQueue<File> queriedFiles = new ConcurrentLinkedQueue<>();
    private final List<ResultData> resultData = new ArrayList<>();

    private boolean error;
    private boolean completed;
    private boolean scanning;
    private int size;
    private final AtomicInteger done = new AtomicInteger();
    private final AtomicInteger totalFilesMalware = new AtomicInteger();

    private CountDownLatch scanningWaitingLatch = null;

    public VulnerabilityScanner(List<File> files) {
        this.queriedFiles.addAll(files);
        this.files.addAll(files);

        // if there is already a different scanner running, then there shouldn't run one more
        synchronized (this) {

            if (latestScanner != null && latestScanner.isScanning()) {
                return;
            }
            latestScanner = this;
        }
        size = files.size();
    }

    public VulnerabilityScanner(File file) {
        this(Collections.singletonList(file));
    }

    public boolean hasMalware() { return totalFilesMalware.get() != 0; }

    public void startScan() { startScan(null); }

    public synchronized void startScan(Appender whenDone) {
        if (scanning || completed) return;

        scanning = true;
        scanningWaitingLatch = new CountDownLatch(1);

        Checks.CheckContainer checkContainer = new Checks.CheckContainer();

        // keep a barrier of maximum 10 threads running concurrently, simulating a fixed thread pool
        Semaphore localBarrier = new Semaphore(10);
        CountDownLatch mainThreadWaitingLatch = new CountDownLatch(size);

        try {
            // check if there is any more files left to be scanned
            while (!queriedFiles.isEmpty()) {

                // try to acquire a permit
                while (localBarrier.tryAcquire()) {

                    // poll an entry from the queue and count down the latch
                    final File file = queriedFiles.poll();

                    // run the scan async
                    CompletableFuture.supplyAsync(() -> {

                        CacheContainer cacheContainer = new CacheContainer();
                        PluginProperties pluginProperties = new PluginProperties(file);
                        boolean hasFileMalware = false;
                        List<CheckResult> results = new ArrayList<>();

                        // loop through the entries of the file system
                        FileSystem fs = ZipUtils.fileSystemForZip(file.toPath());

                        // checks all the different checks
                        for (BaseCheck check : checkContainer.getList()) {

                            Iterator<Path> rootFolderIterator = fs.getRootDirectories().iterator();
                            if (!rootFolderIterator.hasNext()) return null;
                            Path rootFolder = rootFolderIterator.next();

                            // get the result of this check
                            CheckResult checkResult = check.processSingle(file, rootFolder, cacheContainer, pluginProperties);

                            // trigger any malware found
                            if (checkResult instanceof MalwareCheckResult) {
                                if (!hasFileMalware) {
                                    totalFilesMalware.incrementAndGet();
                                    hasFileMalware = true;
                                }
                            }
                            if (checkResult == null) continue;
                            results.add(checkResult);
                        }
                        // mark the result and clear the cache for this file
                        cacheContainer.clearCache(file.toPath());
                        return new ResultData(results, file, getResultLevel(results));

                    }).exceptionally(ex ->
                        new ResultData(
                            Collections.singletonList(new CheckResult("Obfuscated", Risk.HIGH)),
                            file,
                            50
                        )
                    ).thenAccept((result) -> {
                        // release the barrier
                        localBarrier.release();
                        mainThreadWaitingLatch.countDown();

                        // register the result
                        done.incrementAndGet();
                        resultData.add(result);
                    });
                }
            }
            mainThreadWaitingLatch.await();

            // the scanning is now done, let us tell the log
            if (LogHolder.isInUse())
                LogHolder.getScanLogger().log(Level.INFO, Lang.getMessageFormatted(Lang.SCANNING_DONE_LOG, size, totalFilesMalware));

            scanning = false;
            completed = true;

            // let us sort the results to be outputted
            synchronized (resultData) {
                Collections.sort(resultData);
            }

            // run any appender waiting
            if (whenDone != null) whenDone.onResponse();

        } catch (Exception ex) {
            error = true;
            ex.printStackTrace();
        }
        finally {
            scanningWaitingLatch.countDown();
        }
    }

    public boolean await() {
        if (!scanning) return true;

        try {
            scanningWaitingLatch.await();

            return true;
        } catch (Exception ex) {

            ex.printStackTrace();
            return false;
        }
    }

    public double getResultLevel(List<CheckResult> results) {
        double totalLevel = 0;
        for (CheckResult result : results) {
            if (result == null) continue;
            totalLevel += result.getRisk().getDetectionLevel();
        }
        return totalLevel;
    }

    public ConcurrentLinkedQueue<File> getRemainingFiles() {
        return queriedFiles;
    }

    public List<File> getFiles() {
        return files;
    }

    public List<ResultData> getResultData() {
        return resultData;
    }

    public boolean isScanning() {
        return scanning;
    }

    public int getTotalFilesMalware() {
        return totalFilesMalware.get();
    }

    public boolean isError() {
        return this.error;
    }

    public int getSize() {
        return size;
    }

    public int getDoneFiles() {
        return done.get();
    }
}
