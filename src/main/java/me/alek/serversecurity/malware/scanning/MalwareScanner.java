package me.alek.serversecurity.malware.scanning;

import me.alek.serversecurity.lang.Lang;
import me.alek.serversecurity.logging.LogHolder;
import me.alek.serversecurity.malware.checks.BaseCheck;
import me.alek.serversecurity.malware.constants.checks.Checks;
import me.alek.serversecurity.malware.enums.Risk;
import me.alek.serversecurity.malware.model.ResultData;
import me.alek.serversecurity.malware.model.result.CheckResult;
import me.alek.serversecurity.malware.model.result.MalwareCheckResult;
import me.alek.serversecurity.model.PluginProperties;
import org.apache.logging.log4j.Level;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class MalwareScanner extends JarBytecodeScanner<ResultData, CheckResult> {

    public static MalwareScanner latestScanner;
    private static final Checks.CheckContainer checkContainer = new Checks.CheckContainer();

    private final MalwareScannerDelegate scannerDelegate;

    public MalwareScanner(List<File> files, boolean ignoreServersideChecks) {
        super(files, ScannerDelegateFactory.MALWARE_SCANNER_FACTORY.apply(ignoreServersideChecks));

        this.scannerDelegate = (MalwareScannerDelegate) getScannerDelegate();
        this.scannerDelegate.setMalwareScanner(this);
        // if there is already a different scanner running, then there shouldn't run one more
        synchronized (this) {

            if (latestScanner != null && latestScanner.isScanning()) {
                return;
            }
            latestScanner = this;
        }
    }

    public MalwareScanner(File file, boolean ignoreServersideChecks) {
        this(Collections.singletonList(file), ignoreServersideChecks);
    }

    public boolean hasMalware() { return getTotalFilesMalware() > 0; }

    public int getTotalFilesMalware() { return scannerDelegate.totalFilesMalware.get(); }

    @Override
    public Comparator<ResultData> getComparator() {
        return new Comparator<ResultData>() {
            @Override
            public int compare(ResultData o1, ResultData o2) {
                return Double.compare(o1.getLevel(), o2.getLevel());
            }
        };
    }

    public static class MalwareScannerRegistry implements ScannerEventually<ResultData, CheckResult> {

        private final List<CheckResult> checkResults = new ArrayList<>();
        private final MalwareScanner malwareScanner;
        private File file;

        public MalwareScannerRegistry(MalwareScanner malwareScanner) {
            this.malwareScanner = malwareScanner;
        }

        public void setFile(File file) {
            this.file = file;
        }

        @Override
        public List<CheckResult> getAllRegistered() {
            return checkResults;
        }

        @Override
        public void register(CheckResult value) {
            checkResults.add(value);
        }

        @Override
        public void doAdding(List<ResultData> results) {
            results.add(new ResultData(checkResults, file, malwareScanner.getResultLevel(checkResults)));
        }
    }

    public static class MalwareScannerDelegate implements ScannerDelegate<ResultData, CheckResult> {

        private final boolean ignoreServersideChecks;
        private MalwareScanner malwareScanner;

        private final AtomicInteger totalFilesMalware = new AtomicInteger();

        public MalwareScannerDelegate(boolean ignoreServersideChecks) {
            this.ignoreServersideChecks = ignoreServersideChecks;
        }

        public void setMalwareScanner(MalwareScanner scanner) {
            this.malwareScanner = scanner;
        }

        @Override
        public ScannerEventually<ResultData, CheckResult> preHandleAndGetRegistry(File file, Path rootFolder) {
            final ScannerEventually<ResultData, CheckResult> registry = new MalwareScannerRegistry(malwareScanner){{setFile(file);}};

            for (final BaseCheck check : checkContainer.getList()) {

                if (ignoreServersideChecks && check.isServersideCheck()) continue;

                final CheckResult result = check.handlePreProcess(file, rootFolder, new PluginProperties(file));
                if (result != null) registry.register(result);
            }
            return registry;
        }

        @Override
        public void handle(ScannerEventually<ResultData, CheckResult> scannerRegistry, Path classPath, ClassNode classNode, File file, boolean validClassPath) {
            try {
                final List<String> detections = scannerRegistry.getAllRegistered().stream().map(CheckResult::getDetection).collect(Collectors.toList());
                boolean hasFileMalware = false;

                for (final BaseCheck check : checkContainer.getList()) {

                    if (ignoreServersideChecks && check.isServersideCheck()) continue;
                    if (detections.contains(BaseCheck.getCheck(check).getDetection())) continue;

                    // get the result of this check
                    final CheckResult checkResult = check.handleInJar(classPath, classNode, file, validClassPath);

                    // trigger any malware found
                    if (checkResult instanceof MalwareCheckResult) {
                        if (!hasFileMalware) {
                            totalFilesMalware.incrementAndGet();
                            hasFileMalware = true;
                        }
                    }
                    if (checkResult == null) continue;
                    scannerRegistry.register(checkResult);
                    detections.add(checkResult.getDetection());
                }
            } catch (Exception ex) {
                scannerRegistry.register(new CheckResult("Invalid ZIP", Risk.MODERATE));
            }
        }

        @Override
        public void handlePostScan() {
            if (LogHolder.isInUse())
                LogHolder.getScanLogger().log(Level.INFO, Lang.getMessageFormatted(Lang.SCANNING_DONE_LOG, malwareScanner.getSize(), totalFilesMalware));
        }

        @Override
        public void handlePreScan() {

        }
    }
}
