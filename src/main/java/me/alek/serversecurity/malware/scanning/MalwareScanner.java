package me.alek.serversecurity.malware.scanning;

import me.alek.serversecurity.lang.Lang;
import me.alek.serversecurity.logging.LogHolder;
import me.alek.serversecurity.malware.checks.BaseCheck;
import me.alek.serversecurity.malware.constants.checks.Checks;
import me.alek.serversecurity.malware.enums.Risk;
import me.alek.serversecurity.malware.model.ResultData;
import me.alek.serversecurity.malware.model.result.CheckResult;
import me.alek.serversecurity.malware.model.result.MalwareCheckResult;
import me.alek.serversecurity.model.PluginProperties;
import org.apache.logging.log4j.Level;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class MalwareScanner extends JarBytecodeScanner<ResultData> {
    public static MalwareScanner latestScanner;
    private static final Checks.CheckContainer checkContainer = new Checks.CheckContainer();

    private final MalwareScannerDelegate scannerDelegate;

    public MalwareScanner(List<File> files, boolean ignoreServersideChecks) {
        super(files, ScannerDelegateFactory.MALWARE_SCANNER_FACTORY.apply(ignoreServersideChecks));

        this.scannerDelegate = (MalwareScannerDelegate) getScannerDelegate();
        this.scannerDelegate.setMalwareScanner(this);
        // if there is already a different scanner running, then there shouldn't run one more
        synchronized (this) {

            if (latestScanner != null && latestScanner.isScanning()) {
                return;
            }
            latestScanner = this;
        }
    }

    public boolean hasMalware() { return getTotalFilesMalware() > 0; }

    public int getTotalFilesMalware() { return scannerDelegate.totalFilesMalware.get(); }

    public static class MalwareScannerDelegate implements ScannerDelegate<ResultData> {

        private final boolean ignoreServersideChecks;
        private MalwareScanner malwareScanner;

        private final AtomicInteger totalFilesMalware = new AtomicInteger();

        public MalwareScannerDelegate(boolean ignoreServersideChecks) {
            this.ignoreServersideChecks = ignoreServersideChecks;
        }

        public void setMalwareScanner(MalwareScanner scanner) {
            this.malwareScanner = scanner;
        }

        @Override
        public ResultData preHandle(File file, Path rootFolder) {
            final ArrayList<CheckResult> results = new ArrayList<>();
            for (final BaseCheck check : checkContainer.getList()) {

                if (ignoreServersideChecks && check.isServersideCheck()) continue;

                final CheckResult result = check.handlePreProcess(file, rootFolder, new PluginProperties(file));
                if (result != null) results.add(result);
            }
            return new ResultData(results, file, malwareScanner.getResultLevel(results));
        }

        @Override
        public ResultData handle(ResultData preHandleValue, Path classPath, ClassNode classNode, File file, boolean validClassPath) {
            try {
                final List<CheckResult> results = (preHandleValue != null) ? preHandleValue.getResults() : new ArrayList<>();
                final List<String> detections = results.stream().map(CheckResult::getDetection).collect(Collectors.toList());
                boolean hasFileMalware = false;

                for (final BaseCheck check : checkContainer.getList()) {

                    if (ignoreServersideChecks && check.isServersideCheck()) continue;
                    if (detections.contains(BaseCheck.getCheck(check).getDetection())) continue;

                    // get the result of this check
                    final CheckResult checkResult = check.handleInJar(classPath, classNode, file, validClassPath);

                    // trigger any malware found
                    if (checkResult instanceof MalwareCheckResult) {
                        if (!hasFileMalware) {
                            totalFilesMalware.incrementAndGet();
                            hasFileMalware = true;
                        }
                    }
                    if (checkResult == null) continue;
                    results.add(checkResult);
                    detections.add(checkResult.getDetection());
                }
                ResultData resultData = (preHandleValue != null) ? preHandleValue : new ResultData(results, file, malwareScanner.getResultLevel(results));

                if (resultData == preHandleValue) preHandleValue.setLevel(malwareScanner.getResultLevel(results));
                return resultData;
            } catch (Exception ex) {
                return new ResultData(Collections.singletonList(new CheckResult("Invalid ZIP", Risk.MODERATE)), file, 50);
            }
        }

        @Override
        public void handlePostScan() {
            if (LogHolder.isInUse())
                LogHolder.getScanLogger().log(Level.INFO, Lang.getMessageFormatted(Lang.SCANNING_DONE_LOG, malwareScanner.getSize(), totalFilesMalware));
        }

        @Override
        public void handlePreScan() {

        }
    }
}
