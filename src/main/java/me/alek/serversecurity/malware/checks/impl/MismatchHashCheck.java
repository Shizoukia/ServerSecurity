package me.alek.serversecurity.malware.checks.impl;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import me.alek.serversecurity.malware.checks.BaseCheck;
import me.alek.serversecurity.malware.checks.types.DetectionNode;
import me.alek.serversecurity.malware.enums.Risk;
import me.alek.serversecurity.model.PluginProperties;
import org.apache.commons.codec.binary.Base64;
import org.objectweb.asm.tree.ClassNode;

import java.io.*;
import java.math.BigInteger;
import java.net.Socket;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.Semaphore;

public class MismatchHashCheck extends BaseCheck implements DetectionNode {

    private static final Semaphore maxSocketConnections = new Semaphore(1);

    @Override
    public boolean processFileInJar(Path classPath, ClassNode classNode, File file, boolean isClass) {
        return false;
    }

    private String replaceLiteralStringChars(String text) {
        return text
                .replace("'", "")
                .replace("\"", "")
                .replace(" ", "-")
                .replace("+", "-");
    }

    private String getHash(File file) {
        byte[] hash;
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

            byte[] fileData = Files.readAllBytes(Paths.get(file.getPath()));

            hash = messageDigest.digest(fileData);
        } catch (Exception ex) {
            return "";
        }
        return Base64.encodeBase64String(hash);
    }

    private String getAPIPluginInfo(String name, String version) {
        try {
            String urlString = "http://13.42.39.47:8080/plugin?name=%s&version=%s";
            URL url = new URL(String.format(urlString, name, version));

            InputStream stream = url.openConnection().getInputStream();

            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
            return reader.readLine();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return "";
    }

    @Override
    public boolean isServersideCheck() {
        return true;
    }

    private enum TransferMethod { FILE, MESSAGE, HASH, CLOSE }

    private void startTransferMethod(int id, TransferMethod method) {
        startTransferMethod(id, method, null);
    }

    private void startTransferMethod(int id, TransferMethod method, Object object) {

        try (Socket socket = new Socket("13.42.39.47", 12345)) {
            OutputStream stream = socket.getOutputStream();
            DataOutputStream dataStream = new DataOutputStream(stream);

            // write the unique id for this pipeline context
            dataStream.writeLong(id);

            stream.write(method.ordinal() + 1);
            switch (method) {

                case MESSAGE:
                    stream.write(((String) object).getBytes());
                    break;

                case FILE:
                    File file = (File) object;

                    dataStream.writeLong(file.length());

                    FileInputStream fileInputStream = new FileInputStream(file);

                    byte[] buffer = new byte[4096];
                    int bytes;
                    while ((bytes = fileInputStream.read(buffer)) > 0) {
                        stream.write(buffer, 0, bytes);
                    }
                    break;

                case CLOSE:
                    InputStream inputStream = socket.getInputStream();

                    // wait for the server to handle all the methods and finally close the pipeline by sending a response message
                    inputStream.read();
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private void saveHashOfPlugin(File file, String name, String version) {
        int id = new BigInteger(UUID.randomUUID().toString().getBytes()).intValue() + 1000;

        try {
            // maxSocketConnections.acquire();

            startTransferMethod(id, TransferMethod.MESSAGE, name);
            startTransferMethod(id, TransferMethod.MESSAGE, version);
            startTransferMethod(id, TransferMethod.FILE, file);
            startTransferMethod(id, TransferMethod.HASH);
            startTransferMethod(id, TransferMethod.CLOSE);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            // maxSocketConnections.release();
        }
    }

    @Override
    public boolean preProcessJAR(File file, Path rootFolder, PluginProperties pluginProperties) {

        String name = replaceLiteralStringChars(pluginProperties.getPluginName());
        String version = replaceLiteralStringChars(pluginProperties.getVersion());

        String info = getAPIPluginInfo(name, version);
        JsonObject object = new JsonParser().parse(info).getAsJsonObject();

        Optional<JsonObject> savedHashes = Optional.ofNullable(object.get("hashes"))
                .filter((element) -> !element.isJsonNull())
                .map(JsonElement::getAsJsonObject);

        if (savedHashes.isPresent()) {

            // get the hash of this file
            String hash = getHash(file);

            // loop through the stored hashes of this plugin version and compare them to the hash of the file being checked
            JsonObject map = savedHashes.get();
            for (Map.Entry<String, JsonElement> savedHash : map.entrySet()) {

                if (savedHash.getKey().equals(hash)) return false;
            }
        }
        saveHashOfPlugin(file, name, version);

        return savedHashes.isPresent() && savedHashes.get().entrySet().size() > 0;
    }

    @Override
    public String getType() {
        return "Mismatch Hash";
    }

    @Override
    public Risk getRisk() {
        return Risk.HIGH;
    }
}
