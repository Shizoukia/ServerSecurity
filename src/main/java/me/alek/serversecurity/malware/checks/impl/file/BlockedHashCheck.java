package me.alek.serversecurity.malware.checks.impl.file;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import me.alek.serversecurity.malware.checks.BaseCheck;
import me.alek.serversecurity.malware.checks.types.DetectionNode;
import me.alek.serversecurity.malware.enums.Risk;
import me.alek.serversecurity.model.PluginProperties;
import org.apache.commons.codec.binary.Base64;
import org.objectweb.asm.tree.ClassNode;

import java.io.*;
import java.math.BigInteger;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.UUID;
import java.util.concurrent.Semaphore;

public class BlockedHashCheck extends BaseCheck implements DetectionNode {

    private static final String HOST = "3.9.131.36";
    private static final Semaphore maxSocketConnections = new Semaphore(1);

    @Override
    public boolean processFileInJar(Path classPath, ClassNode classNode, File file, boolean isClass) {
        return false;
    }

    private String replaceLiteralStringChars(String text) {
        return text
                .replace("'", "")
                .replace("\"", "")
                .replace(" ", "-")
                .replace("+", "-");
    }

    private String getHash(File file) {
        byte[] hash;
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

            byte[] fileData = Files.readAllBytes(Paths.get(file.getPath()));

            hash = messageDigest.digest(fileData);
        } catch (Exception ex) {
            return "";
        }
        return Base64.encodeBase64String(hash);
    }

    private String getAPIPluginInfo(String name, String version) {
        try {
            String urlString = String.format("http://%s:8080/plugin?name=%s&version=%s", HOST, name, version);
            URL url = new URL(urlString);

            InputStream stream = url.openConnection().getInputStream();

            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
            return reader.readLine();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return "";
    }

    @Override
    public boolean isServersideCheck() {
        return true;
    }

    private enum TransferMethod { FILE, MESSAGE, HASH, CLOSE }

    private void startTransferMethod(int id, TransferMethod method) {
        startTransferMethod(id, method, null);
    }

    private void startTransferMethod(int id, TransferMethod method, Object object) {
        try  {
            Socket socket = new Socket(HOST, 12345);

            OutputStream stream = socket.getOutputStream();
            DataOutputStream dataStream = new DataOutputStream(stream);

            dataStream.writeLong(id);

            stream.write(method.ordinal() + 1);
            switch (method) {
                case MESSAGE:
                    stream.write(((String) object).getBytes());
                    break;

                case FILE:
                    File file = (File) object;
                    FileInputStream fileInputStream = new FileInputStream(file);

                    dataStream.writeLong(file.length());

                    byte[] buffer = new byte[4096];
                    int bytes;
                    while ((bytes = fileInputStream.read(buffer)) > 0) {
                        stream.write(buffer, 0, bytes);
                    }
                    break;
                case CLOSE:
                    InputStream inputStream = socket.getInputStream();

                    System.out.println("waiting for closing context");
                    // wait for the server to handle all the methods and finally close the pipeline by sending a response message
                    inputStream.read();
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private void saveHashOfPlugin(File file, String name, String version) {
        int id = new BigInteger(UUID.randomUUID().toString().getBytes()).intValue() + 1000;

        try {
            maxSocketConnections.acquire();

            startTransferMethod(id, TransferMethod.MESSAGE, name);
            startTransferMethod(id, TransferMethod.MESSAGE, version);
            startTransferMethod(id, TransferMethod.FILE, file);
            startTransferMethod(id, TransferMethod.HASH);
            startTransferMethod(id, TransferMethod.CLOSE);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            maxSocketConnections.release();
        }
    }

    private boolean checkConnection() {
        try {
            URL url = new URL(String.format("http://%s:8080/plugin", HOST));

            URLConnection connection = url.openConnection();

            connection.connect();
            return true;
        } catch (Exception ex) {
            return false;
        }
    }

    @Override
    public boolean preProcessJAR(File file, Path rootFolder, PluginProperties pluginProperties) {
        if (!checkConnection()) return false;

        try {
            String name = replaceLiteralStringChars(pluginProperties.getPluginName());
            String version = replaceLiteralStringChars(pluginProperties.getVersion());

            String info = getAPIPluginInfo(name, version);
            JsonObject object = new JsonParser().parse(info).getAsJsonObject();

            JsonArray jarWindows = object.get("jarWindows").getAsJsonArray();
            JsonArray blacklistedHashes = object.get("blacklistedHashes").getAsJsonArray();

            // get the hash of this file
            String hash = getHash(file);

            // loop through the blacklisted hashes and flag if any of them is equal to the hash of the file being checked
            for (JsonElement blacklistedHash : blacklistedHashes) {

                if (blacklistedHash.getAsString().equals(hash)) return true;
            }
            // loop through the stored hashes of this plugin version and compare them to the hash of the file being checked
            for (JsonElement jarWindow : jarWindows) {

                if (jarWindow.getAsJsonObject().get("hash").getAsString().equals(hash)) return false;
            }
            saveHashOfPlugin(file, name, version);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return false;
    }

    @Override
    public String getType() {
        return "Blocked Hash";
    }

    @Override
    public Risk getRisk() {
        return Risk.HIGH;
    }
}
