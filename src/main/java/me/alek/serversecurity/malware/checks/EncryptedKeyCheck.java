package me.alek.serversecurity.malware.checks;

import me.alek.serversecurity.malware.BytecodeHelper;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.File;
import java.nio.file.Path;
import java.util.ArrayList;

public abstract class EncryptedKeyCheck extends AbstractInstructionCheck {

    public EncryptedKeyCheck() {
        super(MethodInsnNode.class);
    }

    @Override
    public boolean processAbstractInsn(MethodNode methodNode, AbstractInsnNode abstractInsnNode, File file, Path classPath) {
        MethodInsnNode methodInsnNode = (MethodInsnNode) abstractInsnNode;
        ArrayList<String> testStrings = new ArrayList<>();
        switch (methodInsnNode.owner) {
            case "java/lang/String": {
                if (methodInsnNode.getOpcode() == Opcodes.INVOKESPECIAL) {
                    String bytesInvocation = BytecodeHelper.getBytesInvocation(methodInsnNode);
                    if (bytesInvocation != null) {
                        testStrings.add(bytesInvocation);
                    }
                }
            }
            case "java/util/Base64$Decoder": {
                String base64Invocation = BytecodeHelper.getBase64Invocation(methodInsnNode);
                if (base64Invocation != null) {
                    testStrings.add(base64Invocation);
                }
            }
        }
        String lastString = BytecodeHelper.getStringUsed(methodInsnNode);
        if (lastString != null) {
            testStrings.add(lastString);
        }
        for (String testString : testStrings) {
            for (String key : getEncryptedKeys()) {

                if (testString.equals(key)) {
                    return true;
                }
            }
        }
        return false;
    }

    public abstract String[] getEncryptedKeys();
}
