package me.alek.antimalware.scanning;

import me.alek.antimalware.AntiMalwarePlugin;
import me.alek.antimalware.cache.CacheContainer;
import me.alek.antimalware.constants.malware.Handlers;
import me.alek.antimalware.logging.LogHolder;
import me.alek.antimalware.model.DuplicatedValueMap;
import me.alek.antimalware.model.ResultData;
import me.alek.antimalware.utils.Handshake;
import org.apache.logging.log4j.Level;
import org.bukkit.scheduler.BukkitRunnable;

import java.io.File;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Scanner {

    private final ArrayList<File> files;

    private ScanService service;
    private final ArrayList<File> queriedFiles = new ArrayList<>();
    private final List<ResultData> resultData = new ArrayList<>();

    private boolean scanning = false;
    private Instant start;
    private int totalFilesMalware = 0;

    public Scanner(ArrayList<File> files) {
        this.files = files;
        queriedFiles.addAll(files);
    }

    public boolean hasMalware() {
        return totalFilesMalware != 0;
    }

    public void startScan() {
        startScan(null);
    }

    public void startScan(Handshake whenDone) {
        if (ScanHandler.hasScannersRunning()) {
            return;
        }
        ScanHandler.registerScanner(this);
        scanning = true;
        start = Instant.now();

        final Handlers.HandlerContainer handlerContainer = new Handlers.HandlerContainer();
        final CacheContainer cache = new CacheContainer();
        final DuplicatedValueMap<ResultData, Double> resultMap = new DuplicatedValueMap<>();

        service = new ScanService(queriedFiles, resultMap, this, handlerContainer, cache);

        /*ExecutorService executorService = Executors.newFixedThreadPool(files.size());
        for (int i = 0; i <= files.size()-1; i++) {
            executorService.execute(new ScanRunnable(service));
        }*/
        final ExecutorService executorService = Executors.newFixedThreadPool(2);
        for (int i = 0; i <= 1; i++) {
            executorService.execute(new ScanRunnable(service));
        }

        final Scanner scanner = this;
        final BukkitRunnable waitingRunnable = new BukkitRunnable() {
            @Override
            public void run() {
                if (!service.hasMore()) {
                    final List<Map.Entry<ResultData, Double>> pulledEntries = resultMap.getPulledEntries();
                    LogHolder.getScanLogger().log(Level.INFO,"Scannede " + files.size() + " filer igennem og fandt " + totalFilesMalware
                            + " med virus. (" + Duration.between(start, Instant.now()).toMillis() + "ms)");

                    pulledEntries.sort(Map.Entry.comparingByValue());
                    pulledEntries.forEach(entry -> resultData.add(entry.getKey()));

                    ScanHandler.unregisterScanner(scanner);
                    scanning = false;
                    if (whenDone != null) whenDone.onResponse();

                    this.cancel();
                }
            }
        };
        waitingRunnable.runTaskTimer(AntiMalwarePlugin.getInstance(), 0L, 40L);
    }

    public ArrayList<File> getFiles() {
        return files;
    }

    public ScanService getService() {
        return service;
    }

    public ArrayList<File> getQueriedFiles() {
        return queriedFiles;
    }

    public List<ResultData> getResultData() {
        return resultData;
    }

    public boolean isScanning() {
        return scanning;
    }

    public Instant getStart() {
        return start;
    }

    public int getTotalFilesMalware() {
        return totalFilesMalware;
    }

    public void setTotalFilesMalware(int i) {
        this.totalFilesMalware = i;
    }
}
