package me.alek.antimalware.malware.scanning;

import me.alek.antimalware.malware.CacheContainer;
import me.alek.antimalware.malware.constants.checks.Checks;
import me.alek.antimalware.malware.checks.BaseCheck;
import me.alek.antimalware.malware.checks.types.ParseCheck;
import me.alek.antimalware.logging.LogHolder;
import me.alek.antimalware.model.PluginProperties;
import me.alek.antimalware.malware.model.ResultData;
import me.alek.antimalware.malware.model.result.CheckResult;
import me.alek.antimalware.malware.model.result.MalwareCheckResult;
import me.alek.antimalware.utils.Appender;
import me.alek.antimalware.utils.ZipUtils;
import org.apache.logging.log4j.Level;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.*;

public class Scanner {

    public static Scanner latestScanner;

    private final ConcurrentLinkedQueue<File> queriedFiles = new ConcurrentLinkedQueue<>();
    private final List<ResultData> resultData = new ArrayList<>();

    private boolean scanning;
    private int done;
    private int size;
    private int totalFilesMalware;
    private boolean error;

    public Scanner(ArrayList<File> files) {
        queriedFiles.addAll(files);

        // if there is already a different scanner running, then there shouldn't run one more
        if (latestScanner != null && latestScanner.isScanning()) {
            return;
        }
        size = files.size();
        latestScanner = this;
    }

    public boolean hasMalware() {
        return totalFilesMalware != 0;
    }

    public void startScan(Appender whenDone) {
        if (latestScanner != this) {
            return;
        }
        scanning = true;

        Checks.CheckContainer checkContainer = new Checks.CheckContainer();

        // keep a barrier of maximum 10 threads running concurrently, simulating a fixed thread pool
        Semaphore barrier = new Semaphore(10);
        CountDownLatch waitingLatch = new CountDownLatch(queriedFiles.size());

        try {
            // check if there is any more files left to be scanned
            while (!queriedFiles.isEmpty()) {

                // try to acquire a permit
                while (barrier.tryAcquire()) {

                    // poll an entry from the queue and count down the latch
                    File file = queriedFiles.poll();

                    // run the scan async
                    CompletableFuture.supplyAsync(() -> {

                        ResultData resultData = null;
                        CacheContainer cacheContainer = new CacheContainer();
                        PluginProperties pluginProperties = new PluginProperties(file);
                        boolean hasFileMalware = false;
                        List<CheckResult> results = new ArrayList<>();

                        // loop through the entries of the file system
                        try (FileSystem fs = ZipUtils.fileSystemForZip(file.toPath())) {
                            if (fs == null) return null;

                            // checks all the different checks
                            for (BaseCheck check : checkContainer.getList()) {

                                if (check instanceof ParseCheck) {
                                    ((ParseCheck) check).parse();
                                }
                                Iterator<Path> rootFolderIterator = fs.getRootDirectories().iterator();
                                if (!rootFolderIterator.hasNext()) return null;
                                Path rootFolder = rootFolderIterator.next();

                                // get the result of this check
                                CheckResult checkResult = check.processSingle(file, rootFolder, cacheContainer, pluginProperties);

                                // trigger any malware found
                                if (checkResult instanceof MalwareCheckResult) {
                                    if (!hasFileMalware) {
                                        totalFilesMalware++;
                                        hasFileMalware = true;
                                    }
                                }
                                if (checkResult == null) continue;
                                results.add(checkResult);
                            }
                            // mark the result and clear the cache for this file
                            resultData = new ResultData(results, file, getResultLevel(results));
                            cacheContainer.clearCache(file.toPath());

                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        return resultData;
                    }).thenAccept((result) -> {
                        // release the barrier
                        barrier.release();
                        waitingLatch.countDown();

                        // register the result
                        resultData.add(result);
                        done++;
                    });
                }
            }
            waitingLatch.await();

            // the scanning is now done, lets tell the log and sort the results
            LogHolder.getScanLogger().log(Level.INFO,"Scannede " + size + " filer igennem og fandt " + totalFilesMalware
                    + " med virus.");
            scanning = false;
            Collections.sort(resultData);

            // run any appender waiting
            if (whenDone != null) whenDone.onResponse();

        } catch (Exception ex) {
            error = true;
            ex.printStackTrace();
        }
    }

    public double getResultLevel(List<CheckResult> results) {
        double totalLevel = 0;
        for (CheckResult result : results) {
            if (result == null) continue;
            totalLevel += result.getRisk().getDetectionLevel();
        }
        return totalLevel;
    }

    public ConcurrentLinkedQueue<File> getFiles() {
        return queriedFiles;
    }

    public List<ResultData> getResultData() {
        return resultData;
    }

    public boolean isScanning() {
        return scanning;
    }

    public int getTotalFilesMalware() {
        return totalFilesMalware;
    }

    public boolean isError() {
        return this.error;
    }

    public int getSize() {
        return size;
    }

    public int getDone() {
        return done;
    }
}
