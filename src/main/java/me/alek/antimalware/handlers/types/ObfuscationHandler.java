package me.alek.antimalware.handlers.types;

import lombok.Getter;
import me.alek.antimalware.handlers.types.nodes.DetectionNode;
import me.alek.antimalware.model.result.CheckResult;
import me.alek.antimalware.utils.Utils;
import me.alek.antimalware.cache.accepted.AcceptedNameObf;
import me.alek.antimalware.cache.CacheContainer;
import me.alek.antimalware.cache.accepted.AcceptedLibraries;
import me.alek.antimalware.cache.accepted.AcceptedPluginsObfuscated;
import me.alek.antimalware.cache.malware.ObfuscationChecks;
import me.alek.antimalware.enums.Risk;
import me.alek.antimalware.handlers.BaseHandler;
import me.alek.antimalware.handlers.impl.detections.ForceOPCheck;
import me.alek.antimalware.model.DuplicatedValueMap;
import me.alek.antimalware.model.FeatureResponse;
import me.alek.antimalware.model.PluginProperties;
import me.alek.antimalware.obfuscation.handlers.AbstractObfHandler;
import me.alek.antimalware.utils.ZipUtils;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ObfuscationHandler extends BaseHandler implements DetectionNode {

    @Getter
    private static AcceptedNameObf.ObfContainer acceptedNameObfContainer;

    @Override
    public CheckResult processSingle(File file, Path rootFolder, CacheContainer cache, PluginProperties pluginProperties) {

        final AcceptedPluginsObfuscated.ObfContainer acceptedObfuscationPlugins = new AcceptedPluginsObfuscated.ObfContainer();
        if (!ForceOPCheck.validatePluginAcceptance(file.getName(), acceptedObfuscationPlugins.getList())) {
            return null;
        }

        final ObfuscationChecks.ObfContainer obfuscationContainer = new ObfuscationChecks.ObfContainer();
        final AcceptedLibraries.LibrariesContainer checksumLibrariesContainer = new AcceptedLibraries.LibrariesContainer();
        acceptedNameObfContainer = new AcceptedNameObf.ObfContainer();

        try {
            List<Path> libraries = Files.list(rootFolder).collect(Collectors.toList());

            DuplicatedValueMap<Double, String> libraryPercentages = new DuplicatedValueMap<>();

            for (Path library : libraries) {

                if (!Files.isDirectory(library, LinkOption.NOFOLLOW_LINKS)) continue;
                if (library.getFileName().toString().equals("META-INF")) continue;

                Stream<Path> validClasses = ZipUtils.walkThroughFiles(library);
                Iterator<Path> validClassIterator = validClasses.iterator();

                double obfuscationLibraryCount = 0;
                double totalLibraryCount = 0;

                while (validClassIterator.hasNext()) {

                    Path classPath = validClassIterator.next();
                    if (checksumLibrariesContainer.check(classPath.toString())) continue;
                    if (!ZipUtils.validClassPath(classPath)) continue;

                    ClassNode classNode = cache.fetchClass(file.toPath(), classPath);
                    if (classNode == null) continue;

                    totalLibraryCount++;
                    int obfuscationClassCount = 0;

                    for (AbstractObfHandler feature : obfuscationContainer.getList()) {

                        for (Map.Entry<String, FeatureResponse> responseEntry : feature.check(classNode).entrySet()) {

                            FeatureResponse featureResponseModel = responseEntry.getValue();

                            if (!featureResponseModel.getFeedback()) continue;
                            if (!featureResponseModel.isRelevant()) continue;

                            Risk featureRisk = featureResponseModel.getFeatureRisk();
                            obfuscationClassCount += featureRisk.getObfuscationLevel();
                        }
                    }
                    if (obfuscationClassCount >= 2) {
                        obfuscationLibraryCount++;
                    }
                }
                double averagePercentage = Utils.arithmeticSecure(obfuscationLibraryCount, totalLibraryCount);
                if (!Double.isNaN(averagePercentage))
                    libraryPercentages.put(averagePercentage, library.getFileName().toString());
            }

            if (libraryPercentages.getPulledEntries().isEmpty()) return null;
            Map.Entry<Double, String> maxEntry = Collections.max(libraryPercentages.getPulledEntries(), Map.Entry.comparingByKey());
            if (maxEntry.getKey() > 0.55) {
                return new CheckResult("Obfuscated (" + Utils.percentage(maxEntry.getKey()) + ")", Risk.FAKE_CRITICAL, null);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String getType() {
        return "Obfuscation";
    }

    @Override
    public Risk getRisk() {
        return Risk.FAKE_CRITICAL;
    }
}
