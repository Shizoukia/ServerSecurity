package me.alek.antimalware.security;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import me.alek.antimalware.AntiMalwarePlugin;
import me.alek.antimalware.logging.LogHolder;
import me.alek.antimalware.security.blocker.ListenerRegistery;
import me.alek.antimalware.security.operator.OperatorInjector;
import me.alek.antimalware.security.operator.OperatorManager;
import org.bukkit.Bukkit;
import org.bukkit.Server;
import org.bukkit.command.PluginIdentifiableCommand;
import org.bukkit.command.SimpleCommandMap;
import org.bukkit.craftbukkit.v1_8_R3.CraftServer;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.SimplePluginManager;
import org.bukkit.scheduler.BukkitRunnable;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.reflect.Field;
import java.lang.ClassLoader;
import java.lang.reflect.Method;
import java.security.ProtectionDomain;

public class SecurityManager {

    private final AntiMalwarePlugin plugin;
    private final SecurityConfig securityConfig;
    private SecurityOptions options;
    private static SecurityManager instance;

    public static SecurityManager getInstance() {
        return instance;
    }

    public SecurityOptions getOptions() {
        return options;
    }

    public SecurityManager(AntiMalwarePlugin plugin) {
        instance = this;
        this.plugin = plugin;
        this.securityConfig = new SecurityConfig(this);

        init();
    }

    public void generatePluginOptions() {
        final SecurityOptions options = new SecurityOptions(this.securityConfig);
        this.options = options;
        LogHolder.setup(options);
    }

    public void reload() {
        this.securityConfig.reload();
        AntiMalwarePlugin.getInstance().disableLoggingHandlers();
        new BukkitRunnable() {

            @Override
            public void run() {
                generatePluginOptions();
            }
        }.runTaskLater(AntiMalwarePlugin.getInstance(), 10L);
    }

    private static byte[] serialize(Object obj) throws IOException {
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        mapper.writeValue(os, obj);

        return os.toByteArray();
    }

    private void init(){
        generatePluginOptions();
        PluginManager pluginManager = Bukkit.getPluginManager();
        if (this.options.isPreventCancelledMaliciousChatEvents()) {
            try {
                /*PluginManager wrappedPluginManager = new WrappedPluginManager(Bukkit.getPluginManager());
                Field pluginManagerField = ((CraftServer)Bukkit.getServer()).getClass().getDeclaredField("pluginManager");
                pluginManagerField.setAccessible(true);
                pluginManagerField.set(Bukkit.getServer(), wrappedPluginManager);*/


                // istedet for wrapped plugin manager eller ændre bytecode af pluginmanager, så gør jeg ligesom command map
                // med at erstatte alle registeredlistener med en wrapped registered listener i handlerlist associeret med
                // asyncplayerchatevent

                OperatorInjector operatorInjector = new OperatorInjector(OperatorManager.get());
                operatorInjector.inject();

            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        new ListenerRegistery(this, pluginManager);
    }


}
