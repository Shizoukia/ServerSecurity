package me.alek.antimalware.security.blocker.injector;

import me.alek.antimalware.security.blocker.wrappers.WrappedMethodRegisteredListener;
import org.bukkit.Bukkit;
import org.bukkit.event.*;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.plugin.EventExecutor;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.RegisteredListener;
import org.bukkit.plugin.TimedRegisteredListener;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class ListenerInjector implements Injector {

    private boolean injected = false;

    private static HandlerList getHandlerList(Class<? extends Event> clazz) throws Exception {
        while (clazz.getSuperclass() != null && Event.class.isAssignableFrom(clazz.getSuperclass())) {
            try {
                Method method = clazz.getDeclaredMethod("getHandlerList");
                method.setAccessible(true);
                return (HandlerList) method.invoke(null);
            } catch (NoSuchMethodException e) {
                clazz = clazz.getSuperclass().asSubclass(Event.class);
            }
        }
        throw new Exception();
    }

    private static ArrayList<HandlerList> getHandlerLists() throws Exception {
        final Field handlerListField = HandlerList.class.getDeclaredField("allLists");
        handlerListField.setAccessible(true);
        return (ArrayList<HandlerList>) handlerListField.get(null);
    }

    @Override
    public void inject() {
        injected = true;
        final ArrayList<HandlerList> handlers;
        try {
             handlers = getHandlerLists();
        } catch (Exception ex) {
            return;
        }
        final HashMap<Plugin, List<Listener>> listeners = new HashMap<>();
        for (HandlerList handlerList : handlers) {
            for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
                final Plugin plugin = listener.getPlugin();
                if (!listeners.containsKey(plugin)) {
                    listeners.put(plugin, new ArrayList<>());
                }
                if (listeners.get(plugin).contains(listener.getListener())) {
                    continue;
                }
                listeners.get(plugin).add(listener.getListener());
            }
        }
        HandlerList.unregisterAll();
        for (Plugin plugin : listeners.keySet()) {
            for (Listener listener : listeners.get(plugin)) {
                for (Method method : listener.getClass().getDeclaredMethods()) {
                    EventHandler eventHandler = method.getAnnotation(EventHandler.class);
                    if (eventHandler == null) {
                        continue;
                    }
                    method.setAccessible(true);
                    EventExecutor executor = (registeredListener, event) -> {
                        try {
                            method.invoke(registeredListener, event);
                        } catch (InvocationTargetException | IllegalAccessException ex) {
                            throw new EventException(ex.getCause());
                        }
                    };
                    Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
                    HandlerList handlerList;
                    try {
                        handlerList = getHandlerList(eventClass);
                    } catch (Exception ex) {
                        continue;
                    }
                    final RegisteredListener registeredListener;
                    if (!eventClass.isAssignableFrom(AsyncPlayerChatEvent.class)) {
                        if (Bukkit.getPluginManager().useTimings()) {
                            registeredListener = new TimedRegisteredListener(
                                    listener, executor, eventHandler.priority(), plugin, eventHandler.ignoreCancelled()
                            );
                        } else {
                            registeredListener = new RegisteredListener(
                                    listener, executor, eventHandler.priority(), plugin, eventHandler.ignoreCancelled()
                            );
                        }
                    }
                    else {
                        registeredListener = new WrappedMethodRegisteredListener(
                                listener, executor, eventHandler.priority(), plugin, method, eventHandler.ignoreCancelled()
                        );
                    }
                    handlerList.register(registeredListener);
                }
            }
        }
    }

    @Override
    public void reinject() {

    }

    @Override
    public boolean isInjected() {
        return injected;
    }
}
