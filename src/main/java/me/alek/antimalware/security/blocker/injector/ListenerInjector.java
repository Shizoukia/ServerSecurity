package me.alek.antimalware.security.blocker.injector;

import me.alek.antimalware.security.blocker.wrappers.WrappedMethodRegisteredListener;
import org.bukkit.Bukkit;
import org.bukkit.event.*;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.plugin.EventExecutor;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.RegisteredListener;
import org.bukkit.plugin.TimedRegisteredListener;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class ListenerInjector implements Injector {

    private boolean injected = false;
    private static HashMap<HandlerList, List<RegisteredListener>> injectedRegisteredListeners = new HashMap<>();

    private static synchronized HandlerList getHandlerList(Class<? extends Event> clazz) throws Exception {
        while (clazz.getSuperclass() != null && Event.class.isAssignableFrom(clazz.getSuperclass())) {
            try {
                Method method = clazz.getDeclaredMethod("getHandlerList");
                method.setAccessible(true);
                return (HandlerList) method.invoke(null);
            } catch (NoSuchMethodException e) {
                clazz = clazz.getSuperclass().asSubclass(Event.class);
            }
        }
        throw new Exception();
    }

    private static EventExecutor getExecutor(RegisteredListener listener) {
        try {
            Field field = listener.getClass().getDeclaredField("executor");
            field.setAccessible(true);
            return (EventExecutor) field.get(listener);
        } catch (Exception ex) {
            return null;
        }
    }

    private static ArrayList<HandlerList> getHandlerLists() throws Exception {
        final Field handlerListField = HandlerList.class.getDeclaredField("allLists");
        handlerListField.setAccessible(true);
        return (ArrayList<HandlerList>) handlerListField.get(null);
    }

    private static HashMap<Plugin, HashMap<HandlerList, List<RegisteredListener>>> getListeners() {
        final HashMap<Plugin, HashMap<HandlerList, List<RegisteredListener>>> listeners = new HashMap<>();
        final ArrayList<HandlerList> handlers;
        try {
            handlers = getHandlerLists();
        } catch (Exception ex) {
            return listeners;
        }
        for (HandlerList handlerList : handlers) {
            for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
                final Plugin plugin = listener.getPlugin();
                if (!listeners.containsKey(plugin)) {
                    listeners.put(plugin, new HashMap<>());
                }
                if (!listeners.get(plugin).containsKey(handlerList)) {
                    listeners.get(plugin).put(handlerList, new ArrayList<>());
                }
                listeners.get(plugin).get(handlerList).add(listener);
            }
        }
        return listeners;
    }

    private static boolean isEventHandler(Method method) {
        EventHandler eventHandler = method.getAnnotation(EventHandler.class);
        return eventHandler != null && method.getParameterTypes().length == 1;
    }

    private static void injectEventHandler(Plugin plugin, Listener listener, HandlerList handlerList, Method method) {
        method.setAccessible(true);
        final EventHandler eventHandler = method.getAnnotation(EventHandler.class);
        if (eventHandler == null) {
            return;
        }
        final Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
        final EventExecutor executor = (listenerInterface, event) -> {
            try {
                if (eventClass.isAssignableFrom(event.getClass())) {
                    method.invoke(listenerInterface, event);
                }
            } catch (InvocationTargetException | IllegalAccessException ex) {
                throw new EventException(ex.getCause());
            }
        };
        if (handlerList == null) {
            try {
                handlerList = getHandlerList(eventClass);
            } catch (Exception ex) {
                return;
            }
        }
        final boolean isChat = eventClass.isAssignableFrom(AsyncPlayerChatEvent.class);
        addToHandlers(
                handlerList,
                listener,
                executor,
                eventHandler.priority(),
                plugin,
                eventHandler.ignoreCancelled(),
                method,
                isChat
        );
    }

    private static void injectRemaining(HandlerList handlerList, RegisteredListener listener) {

        final EventExecutor executor = getExecutor(listener);
        if (executor == null) {
            return;
        }
        addToHandlers(
                handlerList,
                listener.getListener(),
                executor,
                listener.getPriority(),
                listener.getPlugin(),
                listener.isIgnoringCancelled(),
                null,
                false
        );
    }

    private static void addToHandlers(
                               HandlerList handlerList,
                               Listener listener,
                               EventExecutor executor,
                               EventPriority priority,
                               Plugin plugin,
                               boolean ignoreCancelled,
                               Method method,
                               boolean isChat) {
        final RegisteredListener registeredListener;
        if (isChat && method != null) {

            registeredListener = new WrappedMethodRegisteredListener(
                    listener, executor, priority, plugin, method, ignoreCancelled
            );
        }
        else {
            if (Bukkit.getPluginManager().useTimings()) {
                registeredListener = new TimedRegisteredListener(
                        listener, executor, priority, plugin, ignoreCancelled
                );
            } else {
                registeredListener = new RegisteredListener(
                        listener, executor, priority, plugin, ignoreCancelled
                );
            }
        }
        handlerList.register(registeredListener);
    }

    private void inject(boolean start) {
        final HashMap<Plugin, HashMap<HandlerList, List<RegisteredListener>>> listeners = getListeners();
        final HashMap<HandlerList, List<RegisteredListener>> failedListeners = new HashMap<>();
        final List<Listener> visitedListeners = new ArrayList<>();

        for (Plugin plugin : listeners.keySet()) {
            for (HandlerList handlerList : listeners.get(plugin).keySet()) {
                for (RegisteredListener listener : listeners.get(plugin).get(handlerList)) {
                    if (visitedListeners.contains(listener.getListener())) {
                        continue;
                    }
                    visitedListeners.add(listener.getListener());
                    for (Method method : listener.getClass().getDeclaredMethods()) {

                        Bukkit.broadcastMessage(plugin.getName() +  " " + handlerList + " " + listener.get)
                        if (!isEventHandler(method)) {
                            if (!failedListeners.containsKey(handlerList)) {
                                failedListeners.put(handlerList, new ArrayList<>());
                            }
                            failedListeners.get(handlerList).add(listener);
                            continue;
                        }
                        if (!start) {
                            if (injectedRegisteredListeners.containsKey(handlerList)) {
                                if (injectedRegisteredListeners.get(handlerList).contains(listener)) {
                                    continue;
                                }
                            }
                        }
                        if (!injectedRegisteredListeners.containsKey(handlerList)) {
                            injectedRegisteredListeners.put(handlerList, new ArrayList<>());
                        }
                        injectedRegisteredListeners.get(handlerList).add(listener);
                        injectEventHandler(plugin, listener.getListener(), handlerList, method);
                    }
                }
            }
        }
        for (HandlerList handlerList : failedListeners.keySet()) {
            for (RegisteredListener listener : failedListeners.get(handlerList)) {
                if (!injectedRegisteredListeners.containsKey(handlerList)) {
                    injectedRegisteredListeners.put(handlerList, new ArrayList<>());
                }
                injectedRegisteredListeners.get(handlerList).add(listener);
                injectRemaining(handlerList, listener);
            }
        }
    }

    @Override
    public void inject() {
        this.injected = true;
        HandlerList.unregisterAll();
        inject(true);
    }

    @Override
    public boolean isInjected() {
        return injected;
    }
}
