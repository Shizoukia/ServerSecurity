package me.alek.antimalware.security.blocker.injector;

import me.alek.antimalware.security.blocker.wrappers.WrappedMethodRegisteredListener;
import org.bukkit.Bukkit;
import org.bukkit.event.*;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.plugin.EventExecutor;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.RegisteredListener;
import org.bukkit.plugin.TimedRegisteredListener;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class ListenerInjector implements Injector {

    private boolean injected = false;
    private static HashMap<Listener, List<Method>> injectedRegisteredListeners = new HashMap<>();

    private static synchronized HandlerList getHandlerList(Class<? extends Event> clazz) throws Exception {
        while (clazz.getSuperclass() != null && Event.class.isAssignableFrom(clazz.getSuperclass())) {
            try {
                Method method = clazz.getDeclaredMethod("getHandlerList");
                method.setAccessible(true);
                return (HandlerList) method.invoke(null);
            } catch (NoSuchMethodException e) {
                clazz = clazz.getSuperclass().asSubclass(Event.class);
            }
        }
        throw new Exception();
    }

    private static ArrayList<HandlerList> getHandlerLists() throws Exception {
        final Field handlerListField = HandlerList.class.getDeclaredField("allLists");
        handlerListField.setAccessible(true);
        return (ArrayList<HandlerList>) handlerListField.get(null);
    }

    private static HashMap<Plugin, List<Listener>> getListeners() {
        final HashMap<Plugin, List<Listener>> listeners = new HashMap<>();
        final ArrayList<HandlerList> handlers;
        try {
            handlers = getHandlerLists();
        } catch (Exception ex) {
            return listeners;
        }
        for (HandlerList handlerList : handlers) {
            for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
                final Plugin plugin = listener.getPlugin();
                if (!listeners.containsKey(plugin)) {
                    listeners.put(plugin, new ArrayList<>());
                }
                if (listeners.get(plugin).contains(listener.getListener())) {
                    continue;
                }
                listeners.get(plugin).add(listener.getListener());
            }
        }
        return listeners;
    }

    private static boolean isEventHandler(Method method) {
        EventHandler eventHandler = method.getAnnotation(EventHandler.class);
        return eventHandler != null && method.getParameterTypes().length == 1;
    }

    private static void injectListener(Plugin plugin, Listener listener, Method method) {
        injectedRegisteredListeners.get(listener).add(method);

        method.setAccessible(true);
        EventHandler eventHandler = method.getAnnotation(EventHandler.class);
        Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
        final EventExecutor executor = (listenerInterface, event) -> {
            try {
                if (eventClass.isAssignableFrom(event.getClass())) {
                    method.invoke(listenerInterface, event);
                }
            } catch (InvocationTargetException | IllegalAccessException ex) {
                throw new EventException(ex.getCause());
            }
        };
        HandlerList handlerList;
        try {
            handlerList = getHandlerList(eventClass);
        } catch (Exception ex) {
            return;
        }
        final RegisteredListener registeredListener;
        if (!eventClass.isAssignableFrom(AsyncPlayerChatEvent.class)) {
            if (Bukkit.getPluginManager().useTimings()) {
                registeredListener = new TimedRegisteredListener(
                        listener, executor, eventHandler.priority(), plugin, eventHandler.ignoreCancelled()
                );
            } else {
                registeredListener = new RegisteredListener(
                        listener, executor, eventHandler.priority(), plugin, eventHandler.ignoreCancelled()
                );
            }
        }
        else {
            registeredListener = new WrappedMethodRegisteredListener(
                    listener, executor, eventHandler.priority(), plugin, method, eventHandler.ignoreCancelled()
            );
        }
        handlerList.register(registeredListener);

    }

    @Override
    public void inject() {
        injected = true;
        final HashMap<Plugin, List<Listener>> listeners = getListeners();
        HandlerList.unregisterAll();
        for (Plugin plugin : listeners.keySet()) {
            for (Listener listener : listeners.get(plugin)) {
                injectedRegisteredListeners.put(listener, new ArrayList<>());
                for (Method method : listener.getClass().getDeclaredMethods()) {
                    if (!isEventHandler(method)) {
                        continue;
                    }
                    injectListener(plugin, listener, method);
                }
                Bukkit.broadcastMessage(plugin.getName() + ": " + injectedRegisteredListeners.get(listener));
            }
        }
    }

    @Override
    public void reinject() {
        final HashMap<Plugin, List<Listener>> listeners = getListeners();
        for (Plugin plugin : listeners.keySet()) {
            for (Listener listener : listeners.get(plugin)) {
                for (Method method : listener.getClass().getDeclaredMethods()) {
                    if (!isEventHandler(method)) {
                        continue;
                    }
                    if (injectedRegisteredListeners.get(listener).contains(method)) {
                        continue;
                    }
                    injectListener(plugin, listener, method);
                }
            }
        }
    }

    @Override
    public boolean isInjected() {
        return injected;
    }
}
