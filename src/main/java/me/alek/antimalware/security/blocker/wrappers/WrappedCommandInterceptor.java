package me.alek.antimalware.security.blocker.wrappers;

import me.alek.antimalware.logging.LogHolder;
import me.alek.antimalware.security.blocker.CommandProxy;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.ConsoleCommandSender;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;

public class WrappedCommandInterceptor extends Command {

    private Command delegate;

    protected WrappedCommandInterceptor(String name) {
        super(name);
        this.delegate = null;
    }

    public WrappedCommandInterceptor(Command command, String name) {
        this(name);
        this.delegate = command;
    }

    @Override
    public boolean execute(CommandSender commandSender, String s, String[] strings) {

        final CompletableFuture<Boolean> future;
        if (commandSender instanceof ConsoleCommandSender) {

            future = new CompletableFuture<>();
            final ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);
            executor.execute(() -> {

                CommandProxy proxy = CommandProxy.get();
                future.complete(proxy.intercept(commandSender, this));
            });

        } else {
            return delegate.execute(commandSender, s, strings);
        }

        final AtomicBoolean bool = new AtomicBoolean();
        future.whenComplete((result, throwable) -> {
            if (!result) {
                LogHolder.getSecurityLogger().log(Level.SEVERE, "Kommando blev blokeret: CONSOLE: /"  + s + " " + String.join(" ", strings));
                bool.set(false);
            }
            else {
                bool.set(delegate.execute(commandSender, s, strings));
            }
        });
        return bool.get();
    }


}
