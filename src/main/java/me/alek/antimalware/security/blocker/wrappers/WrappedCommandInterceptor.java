package me.alek.antimalware.security.blocker.wrappers;

import me.alek.antimalware.logging.LogHolder;
import me.alek.antimalware.security.blocker.CommandProxy;
import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.ConsoleCommandSender;

import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.logging.Level;

public class WrappedCommandInterceptor extends Command {

    private Command delegate;

    protected WrappedCommandInterceptor(String name) {
        super(name);
        this.delegate = null;
    }

    public WrappedCommandInterceptor(Command command, String name) {
        this(name);
        this.delegate = command;
    }

    @Override
    public boolean execute(CommandSender commandSender, String s, String[] strings) {
        executeAsync(commandSender, (result) -> {
            if (result) {
                delegate.execute(commandSender, s, strings);
            }
            else {
                LogHolder.getSecurityLogger().log(Level.SEVERE, "Kommando blokeret: CONSOLE: /" + s + " " + String.join(" ", strings));
            }
        });
        return true;
    }

    public void executeAsync(CommandSender commandSender, Consumer<Boolean> callback) {
        if (commandSender instanceof ConsoleCommandSender) {
            CompletableFuture.supplyAsync(() -> {
                CommandProxy proxy = CommandProxy.get();
                return proxy.intercept(commandSender, this);
            }).thenAcceptAsync(callback);
        } else {
            callback.accept(true);
        }
    }


}
